# epigrams
A collection of programming epigrams/aphorisms from the well-known excellent programmers

Right now, many people just have pointers to collections, but the goal is to curate these myself.
Although I try to get links, I'm interested only in good ideas; other people can handle attribution.

## Rob Pike

Compose interfaces, not state machines.

-- from a [2007-05-09 Google Talk](https://www.youtube.com/watch?v=hB05UFqOtFA)

## Alan Perlis

Of course, there's [his own collection](http://www.cs.yale.edu/homes/perlis-alan/quotes.html)

## Edsger Dijkstra

Please don't fall into the trap of believing that I am terribly dogmatic about [the go to statement]. I have the uncomfortable feeling that others are making a religion out of it, as if the conceptual problems of programming could be solved by a simple trick, by a simple form of coding discipline!

LISP has been jokingly described as "the most intelligent way to misuse a computer". I think that description a great compliment because it transmits the full flavor of liberation: it has assisted a number of our most gifted fellow humans in thinking previously impossible thoughts.

The question of whether Machines Can Think... is about as relevant as the question of whether Submarines Can Swim.

I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have liked this", well, that would be enough immortality for me.

There are very different programming styles. I tend to see them as Mozart versus Beethoven. When Mozart started to write, the composition was finished. He wrote the manuscript and it was 'aus einem Guss' (from one cast). In beautiful handwriting, too. Beethoven was a doubter and a struggler who started writing before he finished the composition and then glued corrections onto the page. In one place he did this nine times. When they peeled them, the last version proved identical to the first one.

When we had no computers, we had no programming problem either. When we had a few computers, we had a mild programming problem. Confronted with machines a million times as powerful, we are faced with a gigantic programming problem.

Thank goodness we don't have only serious problems, but ridiculous ones as well. 

Software engineering has accepted as its charter "How to program if you cannot."

If we wish to count lines of code, we should not regard them as "lines produced" but as "lines spent".

### Simplicity and Humility

The art of programming is the art of organizing complexity, of mastering multitude and avoiding its bastard chaos as effectively as possible.

The competent programmer is fully aware of the strictly limited size of his own skull.

Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better.

Our intellectual powers are rather geared to master static relations and that our powers to visualize processes evolving in time are relatively poorly developed.

This is generally true: any sizeable piece of program, or even a complete program package, is only a useful tool that can be used in a reliable fashion, provided that the documentation pertinent for the user is much shorter than the program text. _If any machine or system requires a very thick manual, its usefulness becomes for that very circumstance subject to doubt!_

[I]n programming, simplicity and clarity —in short: what mathematicians call "elegance"— are not a dispensable luxury, but a crucial matter that decides between success and failure.

Testing shows the presence, not the absence of bugs.

If you want more effective programmers, you will discover that they should not waste their time debugging, they should not introduce the bugs to start with.

From a bit to a few hundred megabytes, from a microsecond to a half an hour of computing confronts us with completely baffling ratio of 10^9! The programmer is in the unique position that his is the only discipline and profession in which such a gigantic ratio, which totally baffles our imagination, has to be bridged by a single technology.

### Hard Science

The required techniques of effective reasoning are pretty formal, but as long as programming is done by people that don't master them, the software crisis will remain with us and will be considered an incurable disease.

Industry suffers from the managerial dogma that for the sake of stability and continuity, the company should be independent of the competence of individual employees. Hence industry rejects any methodological proposal that can be viewed as making intellectual demands on its work force. Since in the US the influence of industry is more pervasive than elsewhere, the above dogma hurts American computing science most. The moral of this sad part of the story is that as long as computing science is not allowed to save the computer industry, we had better see to it that the computer industry does not kill computing science.

The world of mathematics all but ignored the programming challenge: programs were so much longer formulae than it was used to that it did not even recognize them as such.

[A program] has unavoidably the uncomfortable property that the smallest possible perturbations —i.e. changes of a single bit— can have the most drastic consequences.

It is not the task of the University to offer what society asks for, but to give what society needs.

### [How do we Tell Truths that might Hurt?](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html)

Programming is one of the most difficult branches of applied mathematics; the poorer mathematicians had better remain pure mathematicians.

The tools we use have a profound (and devious!) influence on our thinking habits, and, therefore, on our thinking abilities.

In spite of its name, software engineering requires (cruelly) hard science for its support.

Projects promoting programming in "natural language" are intrinsically doomed to fail.


## Tony Hoare

There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.

On October 11, 1963, my suggestion was to pass on a request of our customers to relax the ALGOL 60 rule of compulsory declaration of variable names and adopt some reasonable default convention such as that of FORTRAN. […] The story of the Mariner space rocket to Venus, lost because of the lack of compulsory declarations in FORTRAN, was not to be published until later.

At first I hoped that such a technically unsound project would collapse but I soon realized it was doomed to success. Almost anything in software can be implemented, sold, and even used given enough determination.

The price of reliability is the pursuit of the utmost simplicity. It is a price which the very rich find most hard to pay.

# Others

TODO: C.A.R. Hoare, John McCarthy, Donald Knuth, Grace Hopper

That language is an instrument of human reason, and not merely a medium for the expression of thought, is a truth generally admitted.

-- George Bool

[W]e now know that neat flowcharts and lots of comments can't salvage bad code, and that all those microseconds and bytes saved don't help when the program doesn't work. 

-- Kernighan & Plauger

# My Own

State is like a biological weapon: powerful stuff, but unless carefully controlled, it will infect everything.

Building it wrong to please the untrained is just doubling-down on stupid.

